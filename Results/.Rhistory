if (max.obs>0){
y=y[(nrow(set)-max.obs+1):nrow(set),1,drop=F]
yx=yx[(nrow(set)-max.obs+1):nrow(set),1,drop=F]
set=set[(nrow(set)-max.obs+1):nrow(set),]
}
forecast=data.frame(matrix(NA,nrow=ncol(set)+1,length(extract)))
colnames(forecast)=extract
row.names(forecast)=c('ar',colnames(set))
forecast['ar',extract.ar]=unlist(
olsbic3(y,yx,horizon,max.lag)[extract]
)
p1=forecast['ar','p1']
for (i in 1:ncol(set)){# i=1
xx=cbind(yx,set[,i,drop=F])
resu=unlist(
olsbic1setgetting2(y,xx,horizon,max.lag,p1=p1)[extract]
)
if (length(resu)>0){
forecast[colnames(set)[i],extract]=resu
}
}# end model loop
forecast.all[[vint.num]]=forecast
}#end vintage loop
save(forecast.all,file=paste(DirCode,'/results/',target,'_h',horizon,'_maxobs_',max.obs,'.RData',sep=''))
}
horizon
vint.num
var.tlag
i
xx
df=xx
lag.exact<-function(df,lag.length){
# Returns a dataframe of the lags of df with lag.length
x.n=ncol(df)
x.obs=nrow(df)
df.lag=data.frame(matrix(NA,nrow(df),x.n))
x.names=colnames(df)
df.lag[(lag.length+1):nrow(df),]=df[1:(nrow(df)-lag.length),]
rownames(df.lag)=rownames(df)
colnames(df.lag)=paste(colnames(df),'L',lag.length,sep='')
return(df.lag)
}
lag.hormax=function(df,horizon,maxlag){
# returns a lag matrix of the lags of dataframe df from lag=horizon to
# lag=horizon+maxlag-1.
x.n=ncol(df)
x.obs=nrow(df)
for (lag in horizon:(horizon+maxlag-1)){
if (lag==horizon){df.hormax=lag.exact(df,horizon)}else{
df.hormax=cbind(df.hormax,lag.exact(df,lag))
}
}
return(df.hormax)
}
plugin.values<-function(df,max.lag){
# creates the most recent values to be plugged in
# the regression results of lag=1 to max.lag.
# first value will be the most recent value, last
# max.lag-1.
x.obs=nrow(df)
df.lag=lag.hormax(df,1,max.lag-1)
plugin.values=cbind(df[x.obs,],df.lag[x.obs,])
return(plugin.values)
}
ols<-function(df){
# df: matrix/dataframe, first column containts dependent,
# following columns contain regressors.
# returns:
# b: coefficient estimates, tstat and tpval t-test, f and fpval f-test, sse sum
# of squared residuals, sst sum of squared total, sigma2 squared standard error
# n number of observations, p number of regressors.
y=df[,1]
x=matrix(df[,2:ncol(df)],nrow=nrow(df))
x=cbind(1,x)
colnames(x)=c('intercept',colnames(df[,2:ncol(df),drop=F]))
nobs=length(y)
p=ncol(x)-1 # number of exogenous
xy=t(x)%*%y
xxi=solve(t(x)%*%x)
h=x%*%xxi%*%t(x)
i=diag(nobs)
b=xxi%*%xy
bnames=colnames(x)
yhat=x%*%b
res=y-yhat
sst=sum((y-mean(y))^2)
sse=t(res)%*%res
msr=sse/nobs
ssm=sst-sse
r2=1-sse/sst
df.e=nobs-p-1
df.t=nobs-1
df.m=df.t-df.e
s2=sse/df.e
sigma2=sse/(nobs-p)
r2.adj=1-(sse/df.e)/(sst/df.t)
aic=nobs*log(sse/nobs)+2*(p+1)
#         bic=nobs*log(sse/nobs)+log(nobs)*(p+1)
bic=nobs + nobs * log(2*pi) + nobs*log(sse/nobs) + log(nobs) * (p+1)
f=(ssm/df.m)/(sse/df.e)
fpval=1-pf(f,df.m,df.e)
stde=sqrt(diag(xxi))*sqrt(s2)
names(stde)=bnames
tstat=b/stde
tpval=2*(1-pt(tstat,df.e))
res=list(b,stde,tstat,tpval,f,fpval,sse,msr,sst,aic,bic,r2,r2.adj,sigma2,nobs,p)
names(res)=unlist(strsplit("b,stde,tstat,tpval,f,fpval,sse,msr,sst,aic,bic,r2,r2.adj,sigma2,nobs,p",',') )
return(res)
}
nvar=ncol(df)
x1=lag.hormax(df[,1,drop=F],horizon,max.lag)
x2=lag.hormax(df[,2,drop=F],horizon,max.lag)
# restricting to complete cases
xy=cbind(y,x1,x2)
xy.complete=complete.cases(xy)
nobs=sum(xy.complete)
x1=as.matrix(x1[xy.complete,])
x2=as.matrix(x2[xy.complete,])
#         no binary indicators present.
#         if (sum(colSums(x2)==0)>0|(sum(colSums(x2)==nrow(x2)))>0){return()}
y=y[xy.complete,]
View(`x1`)
View(`x2`)
max.obs+horizon+1
max.obs
max.obs+horizon+-1
(nrow(set)
(nrow(set)-max.obs-horizon+1):nrow(set)
27+12
48-2*12
48-22
22
22+26
set.rt=sets[[vint.num]]
set.last.date=names(sets[vint.num])
set.lst.obs=grep(set.last.date,row.names(set.rt))
set.rt=set.rt[1:set.lst.obs,]
set.unrevised=df.unrevised[row.names(set.rt),]
set=cbind(set.rt,set.unrevised)
# drops DISREGARD variables
col.disregard=which(colnames(set)==disregard)
set=set[,-col.disregard]
# DEFLATING some data
deflator=set$CPI/100
deflated.var=row.names(overview)[which(overview$deflated==1)]
deflated.var.new=paste(deflated.var[1:3],'R',sep='')
deflated.var.new[4]=paste(deflated.var[4],'-R',sep='')
set[,deflated.var.new]=set[,deflated.var]*deflator
# PUBLICATION LAG of unrevised data
# (no deflated data need to be lagged further)
variables.tlag=row.names(overview.nr)[overview.nr$lag!=0]
for (var.tlag in variables.tlag){
set[,var.tlag]=lag.exact(set[,var.tlag,drop=F]
,overview.nr[row.names(overview.nr)==var.tlag
,'lag'])
}
# DEPENDENT VARIABLE matrix,
# endogenous regressor and eliminating it in set.
# if unclear, whether publication lag differs for realtime data, run:
#         I=length(sets)
#         lag.ip=matrix(NA,I,1)
#         for (i in 1:I){
#         lo=which(row.names(sets[[i]])==names(sets[i]))
#         lag.ip[i]=sum(is.na(tail(sets[[i]]$'IP'[1:lo])))
#         }
y.raw=set[,target,drop=F]
col.target=which(colnames(set)==target)
set=set[,-col.target]
rm(col.target)
y=1200/horizon*log(y.raw/lag.exact(y.raw,horizon))
yx=1200*log(y.raw/lag.exact(y.raw,1))
colnames(yx)=paste(target,'x',sep='')
# DIFFERENCES
variables.d=row.names(overview)[!is.na(overview$D)]
# target not in set anymore, therefore:
variables.d=variables.d[!variables.d==target]
variables.d.new.name=paste('D',variables.d,sep='')
set[,variables.d.new.name]=diff(set[,variables.d],1,1)
# LOG DIFFERENCES
variables.dln=row.names(overview)[!is.na(overview$D.ln)]
# target not in set anymore, therefore:
variables.dln=variables.dln[!variables.dln==target]
variables.dln.new.name=paste('Dln',variables.dln,sep='')
set[,variables.dln.new.name]=diff(log(set[,variables.dln]),1,1)
# LOG 2.DIFFERENCES
variables.ddln=row.names(overview)[!is.na(overview$D2ln)]
# target not in set anymore, therefore:
variables.ddln=variables.ddln[!variables.ddln==target]
variables.ddln.new.name=paste('DDln',variables.ddln,sep='')
set[,variables.ddln.new.name]=diff(log(set[,variables.ddln]),2,1)
# Eliminating SUPERFLUOUS LEVEL series.
variables.level=row.names(overview)[is.na(overview$L)]
# target not in set anymore, therefore:
variables.level=variables.level[!variables.level==target]
variables.level.cols=which(colnames(set)%in%variables.level)
set=set[,-variables.level.cols]
# PUSHING DOWN all variables
variables=colnames(set)
dates=row.names(set)
y[,1]=push.down(target,y)
yx[,1]=push.down(paste(target,'x',sep=''),yx)
set=data.frame(sapply(variables,push.down,set))
row.names(set)=dates
cons.max=max.obs+horizon
cons.max
if (max.obs>0){
cons.max=max.obs+horizon
y=y[(nrow(set)-max.obs+1):nrow(set),1,drop=F]
yx=yx[(nrow(set)-max.obs+1):nrow(set),1,drop=F]
set=set[(nrow(set)-max.obs+1):nrow(set),]
}
forecast=data.frame(matrix(NA,nrow=ncol(set)+1,length(extract)))
colnames(forecast)=extract
row.names(forecast)=c('ar',colnames(set))
forecast['ar',extract.ar]=unlist(
olsbic3(y,yx,horizon,max.lag)[extract]
)
p1=forecast['ar','p1']
xx=cbind(yx,set[,i,drop=F])
df=xx
# building on ols, lag.exact, lag.hormax and plugin.values, the functions estimates a
# ols model for predicting # of horizons ahead with a maximum lag of max.lag for up x1 and
# x2. The optimal lag lengths p1 for x1 is given by a preceeding analyis.
# p2 of x2 is estimated using bic.
# y and df should data frames.
# Returns: list with all central results (ols estimates, measures of fit, forecast)
# df=xx
# ic='bic
lag.exact<-function(df,lag.length){
# Returns a dataframe of the lags of df with lag.length
x.n=ncol(df)
x.obs=nrow(df)
df.lag=data.frame(matrix(NA,nrow(df),x.n))
x.names=colnames(df)
df.lag[(lag.length+1):nrow(df),]=df[1:(nrow(df)-lag.length),]
rownames(df.lag)=rownames(df)
colnames(df.lag)=paste(colnames(df),'L',lag.length,sep='')
return(df.lag)
}
lag.hormax=function(df,horizon,maxlag){
# returns a lag matrix of the lags of dataframe df from lag=horizon to
# lag=horizon+maxlag-1.
x.n=ncol(df)
x.obs=nrow(df)
for (lag in horizon:(horizon+maxlag-1)){
if (lag==horizon){df.hormax=lag.exact(df,horizon)}else{
df.hormax=cbind(df.hormax,lag.exact(df,lag))
}
}
return(df.hormax)
}
plugin.values<-function(df,max.lag){
# creates the most recent values to be plugged in
# the regression results of lag=1 to max.lag.
# first value will be the most recent value, last
# max.lag-1.
x.obs=nrow(df)
df.lag=lag.hormax(df,1,max.lag-1)
plugin.values=cbind(df[x.obs,],df.lag[x.obs,])
return(plugin.values)
}
ols<-function(df){
# df: matrix/dataframe, first column containts dependent,
# following columns contain regressors.
# returns:
# b: coefficient estimates, tstat and tpval t-test, f and fpval f-test, sse sum
# of squared residuals, sst sum of squared total, sigma2 squared standard error
# n number of observations, p number of regressors.
y=df[,1]
x=matrix(df[,2:ncol(df)],nrow=nrow(df))
x=cbind(1,x)
colnames(x)=c('intercept',colnames(df[,2:ncol(df),drop=F]))
nobs=length(y)
p=ncol(x)-1 # number of exogenous
xy=t(x)%*%y
xxi=solve(t(x)%*%x)
h=x%*%xxi%*%t(x)
i=diag(nobs)
b=xxi%*%xy
bnames=colnames(x)
yhat=x%*%b
res=y-yhat
sst=sum((y-mean(y))^2)
sse=t(res)%*%res
msr=sse/nobs
ssm=sst-sse
r2=1-sse/sst
df.e=nobs-p-1
df.t=nobs-1
df.m=df.t-df.e
s2=sse/df.e
sigma2=sse/(nobs-p)
r2.adj=1-(sse/df.e)/(sst/df.t)
aic=nobs*log(sse/nobs)+2*(p+1)
#         bic=nobs*log(sse/nobs)+log(nobs)*(p+1)
bic=nobs + nobs * log(2*pi) + nobs*log(sse/nobs) + log(nobs) * (p+1)
f=(ssm/df.m)/(sse/df.e)
fpval=1-pf(f,df.m,df.e)
stde=sqrt(diag(xxi))*sqrt(s2)
names(stde)=bnames
tstat=b/stde
tpval=2*(1-pt(tstat,df.e))
res=list(b,stde,tstat,tpval,f,fpval,sse,msr,sst,aic,bic,r2,r2.adj,sigma2,nobs,p)
names(res)=unlist(strsplit("b,stde,tstat,tpval,f,fpval,sse,msr,sst,aic,bic,r2,r2.adj,sigma2,nobs,p",',') )
return(res)
}
nvar=ncol(df)
x1=lag.hormax(df[,1,drop=F],horizon,max.lag)
x2=lag.hormax(df[,2,drop=F],horizon,max.lag)
# restricting to complete cases
xy=cbind(y,x1,x2)
xy.complete=complete.cases(xy)
nobs=sum(xy.complete)
x1=as.matrix(x1[xy.complete,])
x2=as.matrix(x2[xy.complete,])
#         no binary indicators present.
#         if (sum(colSums(x2)==0)>0|(sum(colSums(x2)==nrow(x2)))>0){return()}
y=y[xy.complete,]
xx=cbind(yx,set[,i,drop=F])
set.rt=sets[[vint.num]]
set.last.date=names(sets[vint.num])
set.lst.obs=grep(set.last.date,row.names(set.rt))
set.rt=set.rt[1:set.lst.obs,]
set.unrevised=df.unrevised[row.names(set.rt),]
set=cbind(set.rt,set.unrevised)
# drops DISREGARD variables
col.disregard=which(colnames(set)==disregard)
set=set[,-col.disregard]
# DEFLATING some data
deflator=set$CPI/100
deflated.var=row.names(overview)[which(overview$deflated==1)]
deflated.var.new=paste(deflated.var[1:3],'R',sep='')
deflated.var.new[4]=paste(deflated.var[4],'-R',sep='')
set[,deflated.var.new]=set[,deflated.var]*deflator
# PUBLICATION LAG of unrevised data
# (no deflated data need to be lagged further)
variables.tlag=row.names(overview.nr)[overview.nr$lag!=0]
for (var.tlag in variables.tlag){
set[,var.tlag]=lag.exact(set[,var.tlag,drop=F]
,overview.nr[row.names(overview.nr)==var.tlag
,'lag'])
}
# DEPENDENT VARIABLE matrix,
# endogenous regressor and eliminating it in set.
# if unclear, whether publication lag differs for realtime data, run:
#         I=length(sets)
#         lag.ip=matrix(NA,I,1)
#         for (i in 1:I){
#         lo=which(row.names(sets[[i]])==names(sets[i]))
#         lag.ip[i]=sum(is.na(tail(sets[[i]]$'IP'[1:lo])))
#         }
y.raw=set[,target,drop=F]
col.target=which(colnames(set)==target)
set=set[,-col.target]
rm(col.target)
y=1200/horizon*log(y.raw/lag.exact(y.raw,horizon))
yx=1200*log(y.raw/lag.exact(y.raw,1))
colnames(yx)=paste(target,'x',sep='')
# DIFFERENCES
variables.d=row.names(overview)[!is.na(overview$D)]
# target not in set anymore, therefore:
variables.d=variables.d[!variables.d==target]
variables.d.new.name=paste('D',variables.d,sep='')
set[,variables.d.new.name]=diff(set[,variables.d],1,1)
# LOG DIFFERENCES
variables.dln=row.names(overview)[!is.na(overview$D.ln)]
# target not in set anymore, therefore:
variables.dln=variables.dln[!variables.dln==target]
variables.dln.new.name=paste('Dln',variables.dln,sep='')
set[,variables.dln.new.name]=diff(log(set[,variables.dln]),1,1)
# LOG 2.DIFFERENCES
variables.ddln=row.names(overview)[!is.na(overview$D2ln)]
# target not in set anymore, therefore:
variables.ddln=variables.ddln[!variables.ddln==target]
variables.ddln.new.name=paste('DDln',variables.ddln,sep='')
set[,variables.ddln.new.name]=diff(log(set[,variables.ddln]),2,1)
# Eliminating SUPERFLUOUS LEVEL series.
variables.level=row.names(overview)[is.na(overview$L)]
# target not in set anymore, therefore:
variables.level=variables.level[!variables.level==target]
variables.level.cols=which(colnames(set)%in%variables.level)
set=set[,-variables.level.cols]
# PUSHING DOWN all variables
variables=colnames(set)
dates=row.names(set)
y[,1]=push.down(target,y)
yx[,1]=push.down(paste(target,'x',sep=''),yx)
set=data.frame(sapply(variables,push.down,set))
row.names(set)=dates
# window of max.obs month back
if (max.obs>0){
cons.max=max.obs+horizon
y=y[(nrow(set)-cons.max+1):nrow(set),1,drop=F]
yx=yx[(nrow(set)-cons.max+1):nrow(set),1,drop=F]
set=set[(nrow(set)-cons.max+1):nrow(set),]
}
forecast=data.frame(matrix(NA,nrow=ncol(set)+1,length(extract)))
colnames(forecast)=extract
row.names(forecast)=c('ar',colnames(set))
forecast['ar',extract.ar]=unlist(
olsbic3(y,yx,horizon,max.lag)[extract]
)
p1=forecast['ar','p1']
xx=cbind(yx,set[,i,drop=F])
df=xx
# building on ols, lag.exact, lag.hormax and plugin.values, the functions estimates a
# ols model for predicting # of horizons ahead with a maximum lag of max.lag for up x1 and
# x2. The optimal lag lengths p1 for x1 is given by a preceeding analyis.
# p2 of x2 is estimated using bic.
# y and df should data frames.
# Returns: list with all central results (ols estimates, measures of fit, forecast)
# df=xx
# ic='bic
lag.exact<-function(df,lag.length){
# Returns a dataframe of the lags of df with lag.length
x.n=ncol(df)
x.obs=nrow(df)
df.lag=data.frame(matrix(NA,nrow(df),x.n))
x.names=colnames(df)
df.lag[(lag.length+1):nrow(df),]=df[1:(nrow(df)-lag.length),]
rownames(df.lag)=rownames(df)
colnames(df.lag)=paste(colnames(df),'L',lag.length,sep='')
return(df.lag)
}
lag.hormax=function(df,horizon,maxlag){
# returns a lag matrix of the lags of dataframe df from lag=horizon to
# lag=horizon+maxlag-1.
x.n=ncol(df)
x.obs=nrow(df)
for (lag in horizon:(horizon+maxlag-1)){
if (lag==horizon){df.hormax=lag.exact(df,horizon)}else{
df.hormax=cbind(df.hormax,lag.exact(df,lag))
}
}
return(df.hormax)
}
plugin.values<-function(df,max.lag){
# creates the most recent values to be plugged in
# the regression results of lag=1 to max.lag.
# first value will be the most recent value, last
# max.lag-1.
x.obs=nrow(df)
df.lag=lag.hormax(df,1,max.lag-1)
plugin.values=cbind(df[x.obs,],df.lag[x.obs,])
return(plugin.values)
}
ols<-function(df){
# df: matrix/dataframe, first column containts dependent,
# following columns contain regressors.
# returns:
# b: coefficient estimates, tstat and tpval t-test, f and fpval f-test, sse sum
# of squared residuals, sst sum of squared total, sigma2 squared standard error
# n number of observations, p number of regressors.
y=df[,1]
x=matrix(df[,2:ncol(df)],nrow=nrow(df))
x=cbind(1,x)
colnames(x)=c('intercept',colnames(df[,2:ncol(df),drop=F]))
nobs=length(y)
p=ncol(x)-1 # number of exogenous
xy=t(x)%*%y
xxi=solve(t(x)%*%x)
h=x%*%xxi%*%t(x)
i=diag(nobs)
b=xxi%*%xy
bnames=colnames(x)
yhat=x%*%b
res=y-yhat
sst=sum((y-mean(y))^2)
sse=t(res)%*%res
msr=sse/nobs
ssm=sst-sse
r2=1-sse/sst
df.e=nobs-p-1
df.t=nobs-1
df.m=df.t-df.e
s2=sse/df.e
sigma2=sse/(nobs-p)
r2.adj=1-(sse/df.e)/(sst/df.t)
aic=nobs*log(sse/nobs)+2*(p+1)
#         bic=nobs*log(sse/nobs)+log(nobs)*(p+1)
bic=nobs + nobs * log(2*pi) + nobs*log(sse/nobs) + log(nobs) * (p+1)
f=(ssm/df.m)/(sse/df.e)
fpval=1-pf(f,df.m,df.e)
stde=sqrt(diag(xxi))*sqrt(s2)
names(stde)=bnames
tstat=b/stde
tpval=2*(1-pt(tstat,df.e))
res=list(b,stde,tstat,tpval,f,fpval,sse,msr,sst,aic,bic,r2,r2.adj,sigma2,nobs,p)
names(res)=unlist(strsplit("b,stde,tstat,tpval,f,fpval,sse,msr,sst,aic,bic,r2,r2.adj,sigma2,nobs,p",',') )
return(res)
}
nvar=ncol(df)
x1=lag.hormax(df[,1,drop=F],horizon,max.lag)
x2=lag.hormax(df[,2,drop=F],horizon,max.lag)
xy=cbind(y,x1,x2)
xy.complete=complete.cases(xy)
nobs=sum(xy.complete)
x1=as.matrix(x1[xy.complete,])
x2=as.matrix(x2[xy.complete,])
#         no binary indicators present.
#         if (sum(colSums(x2)==0)>0|(sum(colSums(x2)==nrow(x2)))>0){return()}
y=y[xy.complete,]
View(`x1`)
cons.max
fc=sapply(forecast.all,function(x) x$fc)
View(fc)
fc1=forecast.all[[1]]
View(fc1)
row.names(fc)=row.names(fc1)
View(fc)
write.csv(fc,'fc_test.csv')
getwd()

conf.level = 0.95,
paired=FALSE)$p.value
v1Fp[i,5]<-t.test(YIv1[,i],
YIov1[,i],
mu=0,
alternative = c("two.sided"),
conf.level = 0.95,
paired=FALSE,
var.equal=FALSE)$p.value
v1Fp[i,6]<-t.test(YIv1[,i],
YIov1[,i],
mu=0,
alternative = c("less"),
conf.level = 0.95,
paired=FALSE,
var.equal=FALSE)$p.value
v1Fp[i,7]<-t.test(YIv1[,i],
YIov1[,i],
mu=0,
alternative = c("greater"),
conf.level = 0.95,
paired=FALSE,
var.equal=FALSE)$p.value
}
colnames(v1Fp)[1:7]<-c('F-test','Wicox 2 sided','Wlilcox less','Wlilcox greater', 'Welsh 2 sided', 'Welsh less', 'Welsh greater')
v1Fp
plot(apply(YIv0[1:13,],2,mean))
lines(apply((Y-INT)[,1:s],2,mean,na.rm=TRUE))#vergleich der "normalen" renditen für diese anlagehorizonte
plot(apply(YIv1[1:13,],2,mean))
abline(h=0)
lines(apply((Y-INT)[,1:s],2,mean,na.rm=TRUE))#vergleich der "normalen" renditen für diese anlagehorizonte
plot(apply(YIv1[1:13,9:40],2,mean))
abline(h=0)
lines(apply((Y-INT)[,9:40],2,mean,na.rm=TRUE))#ve
library("foreign", lib.loc="C:/Users/dulbricht/Documents/R/R-3.0.0/library")
load("F:/Cost Averaging/1308 USA baisdaten.RData")
#expansion
s<-12
v0<-baa(g0[,2],s)# indexmatrix der intervalle vor einer expansion
Yv0<-matrix(NA,nrow(v0),s) # ergebnismatrix: Y (v0phasen x intervallänge)
INTv0<-matrix(NA,nrow(v0),s) # ergebnismatrix: Y (v0phasen x intervallänge)
v0ind<-matrix(NA,nrow(v0)*s,2)#untereinander gestapelte indexwerte der v0
for (a in 1:s){
Yv0[,a]=Y[cbind(v0[,a],a)]
INTv0[,a]=INT[cbind(v0[,a],a)]
v0ind[(nrow(v0)*(a-1)+1):(nrow(v0)*a),]=cbind(v0[,a],a)# id der expansion ergebnisse bestimmter länge
}
YIv0<-Yv0-INTv0
YIov0<-YI# für den f-test: die YI ohne die expansionsphasen bestimmter länge (1:40)
YIov0[v0ind]<-NA
g0=g[g[,4]==0,]
g00<-matrix(g0[,c(1,3)],nrow(g0),2)
g00[,2]=g00[,2]-sp+1# anpassen, da in der 1. spalte die werte der kürzesten anlageperiod sp stehen.
# CONTRACTION
g1=g[g[,4]==1,]
g11=matrix(g1[,c(1,3)],nrow(g1),2)
g11[,2]=g11[,2]-sp+1
if(g[1,4]==0){
g00[1,1]<-2 # die erste beobachtung beginnt immer erst bei 2
g00[1,2]<-g00[1,2]-1 # da die erste beobachtung immer erst bei 2 beginnt, ist die anlage auch 1 monat kürzer
}else{
g11[1,1]<-2 # die erste beobachtung beginnt immer erst bei 2
g11[1,2]<-g11[1,2]-1}
#INTERVALLE VOR UND NACH EXPANSION/CONTRACTION
#expansion
s<-12
v0<-baa(g0[,2],s)# indexmatrix der intervalle vor einer expansion
Yv0<-matrix(NA,nrow(v0),s) # ergebnismatrix: Y (v0phasen x intervallänge)
INTv0<-matrix(NA,nrow(v0),s) # ergebnismatrix: Y (v0phasen x intervallänge)
v0ind<-matrix(NA,nrow(v0)*s,2)#untereinander gestapelte indexwerte der v0
for (a in 1:s){
Yv0[,a]=Y[cbind(v0[,a],a)]
INTv0[,a]=INT[cbind(v0[,a],a)]
v0ind[(nrow(v0)*(a-1)+1):(nrow(v0)*a),]=cbind(v0[,a],a)# id der expansion ergebnisse bestimmter länge
}
YIv0<-Yv0-INTv0
YIov0<-YI# für den f-test: die YI ohne die expansionsphasen bestimmter länge (1:40)
YIov0[v0ind]<-NA
v0Fp<-matrix(NA,s,9)
for (i in 1:s){
v0Fp[i,1]<-var.test(YIv0[,i],
YIov0[,i],
ratio = 1,
alternative = c("two.sided"),
conf.level = 0.95)$p.value
v0Fp[i,2]<-wilcox.test(YIv0[,i],
YIov0[,i],
mu=0,
alternative = c("two.sided"),
conf.level = 0.95,
paired=FALSE)$p.value
v0Fp[i,3]<-wilcox.test(YIv0[,i],
YIov0[,i],
mu=0,
alternative = c("less"),
conf.level = 0.95,
paired=FALSE)$p.value
v0Fp[i,4]<-wilcox.test(YIv0[,i],
YIov0[,i],
mu=0,
alternative = c("greater"),
conf.level = 0.95,
paired=FALSE)$p.value
v0Fp[i,5]<-t.test(YIv0[,i],
YIov0[,i],
mu=0,
alternative = c("two.sided"),
conf.level = 0.95,
paired=FALSE,
var.equal=FALSE)$p.value
v0Fp[i,6]<-t.test(YIv0[,i],
YIov0[,i],
mu=0,
alternative = c("less"),
conf.level = 0.95,
paired=FALSE,
var.equal=FALSE)$p.value
v0Fp[i,7]<-t.test(YIv0[,i],
YIov0[,i],
mu=0,
alternative = c("greater"),
conf.level = 0.95,
paired=FALSE,
var.equal=FALSE)$p.value
v0Fp[i,8]<-t.test(YIv0[,i],
mu=0,
alternative = c("greater"),
conf.level = 0.95)$p.value
v0Fp[i,9]<-t.test(YIv0[,i],
mu=0,
alternative = c("less"),
conf.level = 0.95)$p.value
}
v0Fp
YIv0
v0Fp
load("F:/Cost Averaging/USA 02.08.RData")
RCY<-Y-YLS
View(RCY)
save.image("~/1908.RData")
RCY0<-matrix(NA,nrow(v0,s*2))
g0=g[g[,4]==0,]
g00<-matrix(g0[,c(1,3)],nrow(g0),2)
g00[,2]=g00[,2]-sp+1# anpassen, da in der 1. spalte die werte der kürzesten anlageperiod sp stehen.
# CONTRACTION
g1=g[g[,4]==1,]
g11=matrix(g1[,c(1,3)],nrow(g1),2)
g11[,2]=g11[,2]-sp+1
if(g[1,4]==0){
g00[1,1]<-2 # die erste beobachtung beginnt immer erst bei 2
g00[1,2]<-g00[1,2]-1 # da die erste beobachtung immer erst bei 2 beginnt, ist die anlage auch 1 monat kürzer
}else{
g11[1,1]<-2 # die erste beobachtung beginnt immer erst bei 2
g11[1,2]<-g11[1,2]-1}
#INTERVALLE VOR UND NACH peak/trough
#peak
s<-12
#SONDERLOCKE: 14. turning point ist das datenende...daher hier 1:13
v0<-baa(g0[1:13,2],s)# indexmatrix der intervalle vor einer expansion
YILS0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCAI0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCALS0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
RCY0<-matrix(NA,nrow(v0,s*2))
YI0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
v0ind<-matrix(NA,nrow(v0)*s*2,2)#untereinander gestapelte indexwerte der v0
aux<-c(s:1,1:s)
for (a in 1:(s*2)){
YILS0[,a]=YILS[cbind(v0[,a],aux[a])]
DCAI0[,a]=DCAI[cbind(v0[,a],aux[a])]
DCALS0[,a]=DCALS[cbind(v0[,a],aux[a])]
RCY0[,a]=RCY[cbind(v0[,a],aux[a])]
YI0[,a]=YI[cbind(v0[,a],aux[a])]
v0ind[(nrow(v0)*(a-1)+1):(nrow(v0)*a),]=cbind(v0[,a],aux[a])# id der expansion ergebnisse bestimmter länge
}
DCAI<-DCA-INTLS[1:nrow(DCA),1:ncol(DCA)]
DCALS<-DCA-YLS[1:nrow(DCA),1:ncol(DCA)]
View(YDCA)
DCAI<-YDCA-INTLS[1:nrow(DCA),1:ncol(DCA)]
DCAI<-YDCA-INTLS[1:nrow(YDCA),1:ncol(YDCA)]
DCALS<-YDCA-YLS[1:nrow(YDCA),1:ncol(YDCA)]
g0=g[g[,4]==0,]
g00<-matrix(g0[,c(1,3)],nrow(g0),2)
g00[,2]=g00[,2]-sp+1# anpassen, da in der 1. spalte die werte der kürzesten anlageperiod sp stehen.
# CONTRACTION
g1=g[g[,4]==1,]
g11=matrix(g1[,c(1,3)],nrow(g1),2)
g11[,2]=g11[,2]-sp+1
if(g[1,4]==0){
g00[1,1]<-2 # die erste beobachtung beginnt immer erst bei 2
g00[1,2]<-g00[1,2]-1 # da die erste beobachtung immer erst bei 2 beginnt, ist die anlage auch 1 monat kürzer
}else{
g11[1,1]<-2 # die erste beobachtung beginnt immer erst bei 2
g11[1,2]<-g11[1,2]-1}
#INTERVALLE VOR UND NACH peak/trough
#peak
s<-12
#SONDERLOCKE: 14. turning point ist das datenende...daher hier 1:13
v0<-baa(g0[1:13,2],s)# indexmatrix der intervalle vor einer expansion
YILS0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCAI0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCALS0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
RCY0<-matrix(NA,nrow(v0,s*2))
YI0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
v0ind<-matrix(NA,nrow(v0)*s*2,2)#untereinander gestapelte indexwerte der v0
aux<-c(s:1,1:s)
for (a in 1:(s*2)){
YILS0[,a]=YILS[cbind(v0[,a],aux[a])]
DCAI0[,a]=DCAI[cbind(v0[,a],aux[a])]
DCALS0[,a]=DCALS[cbind(v0[,a],aux[a])]
RCY0[,a]=RCY[cbind(v0[,a],aux[a])]
YI0[,a]=YI[cbind(v0[,a],aux[a])]
v0ind[(nrow(v0)*(a-1)+1):(nrow(v0)*a),]=cbind(v0[,a],aux[a])# id der expansion ergebnisse bestimmter länge
}
RCY0<-matrix(NA,nrow(v0,s*2))
RCY0<-matrix(NA,nrow(v0),s*2)
s<-12
#SONDERLOCKE: 14. turning point ist das datenende...daher hier 1:13
v0<-baa(g0[1:13,2],s)# indexmatrix der intervalle vor einer expansion
YILS0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCAI0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCALS0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
RCY0<-matrix(NA,nrow(v0),s*2)
YI0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
v0ind<-matrix(NA,nrow(v0)*s*2,2)#untereinander gestapelte indexwerte der v0
aux<-c(s:1,1:s)
for (a in 1:(s*2)){
YILS0[,a]=YILS[cbind(v0[,a],aux[a])]
DCAI0[,a]=DCAI[cbind(v0[,a],aux[a])]
DCALS0[,a]=DCALS[cbind(v0[,a],aux[a])]
RCY0[,a]=RCY[cbind(v0[,a],aux[a])]
YI0[,a]=YI[cbind(v0[,a],aux[a])]
v0ind[(nrow(v0)*(a-1)+1):(nrow(v0)*a),]=cbind(v0[,a],aux[a])# id der expansion ergebnisse bestimmter länge
}
g0=g[g[,4]==0,]
g00<-matrix(g0[,c(1,3)],nrow(g0),2)
g00[,2]=g00[,2]-sp+1# anpassen, da in der 1. spalte die werte der kürzesten anlageperiod sp stehen.
# CONTRACTION
g1=g[g[,4]==1,]
g11=matrix(g1[,c(1,3)],nrow(g1),2)
g11[,2]=g11[,2]-sp+1
if(g[1,4]==0){
g00[1,1]<-2 # die erste beobachtung beginnt immer erst bei 2
g00[1,2]<-g00[1,2]-1 # da die erste beobachtung immer erst bei 2 beginnt, ist die anlage auch 1 monat kürzer
}else{
g11[1,1]<-2 # die erste beobachtung beginnt immer erst bei 2
g11[1,2]<-g11[1,2]-1}
#INTERVALLE VOR UND NACH peak/trough
#peak
s<-12
#SONDERLOCKE: 14. turning point ist das datenende...daher hier 1:13
v0<-baa(g0[1:13,2],s)# indexmatrix der intervalle vor einer expansion
YILS0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCAI0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCALS0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
RCY0<-matrix(NA,nrow(v0),s*2)
YI0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
v0ind<-matrix(NA,nrow(v0)*s*2,2)#untereinander gestapelte indexwerte der v0
aux<-c(s:1,1:s)
for (a in 1:(s*2)){
YILS0[,a]=YILS[cbind(v0[,a],aux[a])]
DCAI0[,a]=DCAI[cbind(v0[,a],aux[a])]
DCALS0[,a]=DCALS[cbind(v0[,a],aux[a])]
RCY0[,a]=RCY[cbind(v0[,a],aux[a])]
YI0[,a]=YI[cbind(v0[,a],aux[a])]
v0ind[(nrow(v0)*(a-1)+1):(nrow(v0)*a),]=cbind(v0[,a],aux[a])# id der expansion ergebnisse bestimmter länge
}
a
YILS0[,a]
DCAI0[,a]
DCALS0[,a]
RCY0[,a]
RCY0
View(RCY0)
fix(aux)
for (a in 1:(s*2)){
YILS0[,a]=YILS[cbind(v0[,a],aux[a])]
#DCAI0[,a]=DCAI[cbind(v0[,a],aux[a])]
#DCALS0[,a]=DCALS[cbind(v0[,a],aux[a])]
RCY0[,a]=RCY[cbind(v0[,a],aux[a])]
YI0[,a]=YI[cbind(v0[,a],aux[a])]
v0ind[(nrow(v0)*(a-1)+1):(nrow(v0)*a),]=cbind(v0[,a],aux[a])# id der expansion ergebnisse bestimmter länge
}
for (a in 1:(s*2)){
YILS0[,a]=YILS[cbind(v0[,a],aux[a])]
#DCAI0[,a]=DCAI[cbind(v0[,a],aux[a])]
#DCALS0[,a]=DCALS[cbind(v0[,a],aux[a])]
#RCY0[,a]=RCY[cbind(v0[,a],aux[a])]
YI0[,a]=YI[cbind(v0[,a],aux[a])]
v0ind[(nrow(v0)*(a-1)+1):(nrow(v0)*a),]=cbind(v0[,a],aux[a])# id der expansion ergebnisse bestimmter länge
}
a
for (a in 1:(s*2)){
YILS0[,a]=YILS[cbind(v0[,aux[a]],aux[a])]
DCAI0[,a]=DCAI[cbind(v0[,aux[a]],aux[a])]
DCALS0[,a]=DCALS[cbind(v0[,aux[a]],aux[a])]
RCY0[,a]=RCY[cbind(v0[,aux[a]],aux[a])]
YI0[,a]=YI[cbind(v0[,aux[a]],aux[a])]
v0ind[(nrow(v0)*(a-1)+1):(nrow(v0)*a),]=cbind(v0[,aux[a]],aux[a])# id der expansion ergebnisse bestimmter länge
}
RCY0
save.image("F:/Cost Averaging/1908.RData")
v0[,aux[a]]
apply(RCY,2,mean)/apply(RCY,2,sd)
apply(RCY,1,mean)/apply(RCY,1,sd)
g0=g[g[,4]==0,]
g00<-matrix(g0[,c(1,3)],nrow(g0),2)
g00[,2]=g00[,2]-sp+1# anpassen, da in der 1. spalte die werte der kürzesten anlageperiod sp stehen.
# CONTRACTION
g1=g[g[,4]==1,]
g11=matrix(g1[,c(1,3)],nrow(g1),2)
g11[,2]=g11[,2]-sp+1
if(g[1,4]==0){
g00[1,1]<-2 # die erste beobachtung beginnt immer erst bei 2
g00[1,2]<-g00[1,2]-1 # da die erste beobachtung immer erst bei 2 beginnt, ist die anlage auch 1 monat kürzer
}else{
g11[1,1]<-2 # die erste beobachtung beginnt immer erst bei 2
g11[1,2]<-g11[1,2]-1}
#INTERVALLE VOR UND NACH peak/trough
#peak
s<-12
#SONDERLOCKE: 14. turning point ist das datenende...daher hier 1:13
v0<-baa(g0[1:13,2],s)# indexmatrix der intervalle vor einer expansion
YILS0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCAI0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCALS0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
RCY0<-matrix(NA,nrow(v0),s*2)
YI0<-matrix(NA,nrow(v0),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
v0ind<-matrix(NA,nrow(v0)*s*2,2)#untereinander gestapelte indexwerte der v0
aux<-c(s:1,1:s)
for (a in 1:(s*2)){
YILS0[,a]=YILS[cbind(v0[,aux[a]],aux[a])]
DCAI0[,a]=DCAI[cbind(v0[,aux[a]],aux[a])]
DCALS0[,a]=DCALS[cbind(v0[,aux[a]],aux[a])]
RCY0[,a]=RCY[cbind(v0[,aux[a]],aux[a])]
YI0[,a]=YI[cbind(v0[,aux[a]],aux[a])]
v0ind[(nrow(v0)*(a-1)+1):(nrow(v0)*a),]=cbind(v0[,aux[a]],aux[a])# id der expansion ergebnisse bestimmter länge
}
View(RCY0)
apply(RCY0,2,mean)
apply(RCY0,2,mean)/apply(RCY0,2,sd)
RCY1<-matrix(NA,nrow(v1),s*2)
s<-12
#SONDERLOCKE: 14. turning point ist das datenende...daher hier 1:13
v1<-baa(g1[1:13,2],s)# indexmatrix der intervalle vor einer expansion
YILS1<-matrix(NA,nrow(v1),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCAI1<-matrix(NA,nrow(v1),s*2) # ergebnismatrix: Y (v0phasen x intervallänge)
DCALS1<-matrix(NA,nrow(v1),s*2) # ergebnismatrix: Y (v1phasen x intervallänge)
RCY1<-matrix(NA,nrow(v1),s*2)
YI1<-matrix(NA,nrow(v1),s*2) # ergebnismatrix: Y (v1phasen x intervallänge)
v1ind<-matrix(NA,nrow(v1)*s*2,2)#untereinander gestapelte indexwerte der v1
aux<-c(s:1,1:s)
for (a in 1:(s*2)){
YILS1[,a]=YILS[cbind(v1[,aux[a]],aux[a])]
DCAI1[,a]=DCAI[cbind(v1[,aux[a]],aux[a])]
DCALS1[,a]=DCALS[cbind(v1[,aux[a]],aux[a])]
RCY1[,a]=RCY[cbind(v1[,aux[a]],aux[a])]
YI1[,a]=YI[cbind(v1[,aux[a]],aux[a])]
v1ind[(nrow(v1)*(a-1)+1):(nrow(v1)*a),]=cbind(v1[,aux[a]],aux[a])# id der expansion ergebnisse bestimmter länge
}
apply(RCY1,2,mean)/apply(RCY1,2,sd)
tt<-apply(RCY1,2,mean)/apply(RCY1,2,sd)
fix(tt)
apply(RCY0,2,mean)/apply(RCY0,2,sd)
View(INT)
plot(int)
tbill<-ts(int,start=c(1934,1),freq=12)
plot(tbill)
load("I:/Praktikanten/Nauhaus/05 Spline Methode/R/splinerohdaten.csv")
dataQ = read.table("splinerohdaten.csv", header = TRUE, sep = ",", dec = ".")
setwd("I:/Praktikanten/Nauhaus/Spline Methode")
dataQ = read.table("splinerohdaten.csv", header = TRUE, sep = ",", dec = ".")
setwd("I:/Praktikanten/Nauhaus/Spline Methode/R")
library("fpp", lib.loc="C:/Users/dulbricht/Documents/R/R-3.0.0/library")
load("F:/Hertie School of Governance/Vorlesung/cons.xlsx")
cons <- read.table("F:/Hertie School of Governance/Vorlesung/cons.csv", header=T, quote="\"")
View(cons)
?adf
adf.test(cons)
c=matrix(x,218,1)
c=matrix(cons,218,1)
adf.test(c)
?adf.test
co=c(cons)
cons=ts(cons,s=c(1959,1),f=4)
plot(cons)
adf.test(cons)
adf.test(d(cons)
)
adf.test(dif(cons)
)
adf.test(diff(cons))
?diff
cons <- read.csv("F:/Hertie School of Governance/Vorlesung/cons.csv")
View(cons)
cons<-ts(cons,s=c(1959,1),f=4)
plot(cons)
adf.test(cons)
str(cons)
fix(cons)
adf.test(cons$con)
adf.test(cons$cons)
adf.test(cons[,1])
test=cons
test=cbind(test,ln(test))
test=cbind(test,log(test))
cons=cbind(cons,log(cons))
plot(cons[,c(3,4)])
plot(cons[,1])
plot(cons[name=cons])
plot(cons[,name=cons])
plot(cons)
View(cons)
names(cons)
?mts
?ts
str(cons)
cons<-ts(cons,s=c(1959,1),f=4)
plot(cons)
fix(cons)
cons<-ts(cons,s=c(1959,1),f=4)
str(cons)
cons<-ts(cons,s=c(1959,1),f=4,names=c('cons','inc','ln(cons)','ln(inc)'))
plot(cons)
adf.test(cons[,3])
adf.test(cons[,3])
adf.test(cons[,4])
cons=cbind(cons, diff(cons))
cons<-ts(cons,s=c(1959,1),f=4,names=c('cons','inc','ln(cons)','ln(inc)','dif(cons)','dif(inc)','dif(ln(cons))','dif(ln(inc))'))
plot(cons)
save.image("F:/Hertie School of Governance/Vorlesung/cons.RData")
data <- read.csv("F:/Hertie School of Governance/Vorlesung/cons.csv")
data <- read.csv("F:/Hertie School of Governance/Vorlesung/cons.csv")
fit.ex3 <- lm(cons ~ inc, data=cons)
summary(fit.ex3)
res3 <- ts(resid(fit.ex3),s=1959.1,f=4)
plot(res3)
Acf(res3)
?Acf
Pacf(res3)
save.image("F:/Hertie School of Governance/Vorlesung/cons.RData")
plot(cons)
plot(cons,data=cons)
save.image("F:/Hertie School of Governance/Vorlesung/cons.RData")
letters(1:6)
letters[1:3]
LETTERS[1:3]
month.ab[1:6]
month.abb[1:6]
month.name[1:6]
cummin (c(3:1 , 2:0 , 4:2) )
(c(3:1 , 2:0 , 4:2) )
myframe[,1]
source('H:/git/zeit-2/SentiWS_2014_11_25_Zeit.R', echo=TRUE)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
source('H:/git/zeit-2/SentiWS_2014_11_25_Zeit.R', echo=TRUE)
View(Ergebnis)
source('H:/git/zeit-2/Bind_articles_together.R', echo=TRUE)
i
subd
listfiles=dir(paste(DirRawTexts,'/',subd,sep=''))
listplaintexts=listfiles[grep('plaintxt',listfiles)]
ids=gsub('plaintxt','',listplaintexts)
ids=gsub('.txt','',ids)
ids=gsub('^-','',ids)
# Texts with multiple pages -----------------------------------------------
mtext=ids[grep('-',ids)]
mtext=strsplit(mtext,'-')
mtext=t(sapply(mtext,function(x){as.numeric(x[1:2])}))
idsm=unique(mtext[,1])
idsm=sort(idsm)
# Files with just one page ------------------------------------------------
stext=as.numeric(ids[-grep('-',ids)])
stext=stext[(stext%in%idsm)==0]
stext=sort(stext)
# onepager: copy plaintexts into articles  --------------------------------
for (i in 1:length(stext)){
file.copy(paste(DirRawTexts,'/',subd,'/','plaintxt-',stext[i],'.txt',sep=''),
paste(DirRawTexts,'/',subd,'/','article-',stext[i],'.txt',sep=''))
}
rm(i)
# m-pager: aggregate and save them as articles -------------------------------------------------
for (i in 1:length(idsm)){
nidsm=nrow(mtext[mtext[,1]==idsm[i],])
article=character(nidsm)
for (page in 1:nidsm){
article[page]=readLines(paste(DirRawTexts,'/',subd,'/','plaintxt-',idsm[i],'-',page,'.txt',sep=''),encoding='UTF-8')
}
article=paste(article,sep="",collapse="")
article=gsub(register$title[idsm[i]],'',article)
write.csv(article,
paste(DirRawTexts,'/',subd,'/','article-',idsm[i],'.txt',sep='')
)
}
i
nidsm=nrow(mtext[mtext[,1]==idsm[i],])
article=character(nidsm)
for (page in 1:nidsm){
article[page]=readLines(paste(DirRawTexts,'/',subd,'/','plaintxt-',idsm[i],'-',page,'.txt',sep=''),encoding='UTF-8')
}
article=paste(article,sep="",collapse="")
article=gsub(register$title[idsm[i]],'',article)
register$title[idsm[i]]
(length(register$title[idsm[i]])>80)
(nchar(register$title[idsm[i]])>80)
(nchar(as.character(register$title[idsm[i]]))>80)
nchar(as.character(register$title[idsm[i]]))
idsm[i]
subd
grep(subd,listsubdirs)
source('H:/git/zeit-2/Bind_articles_together.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
grep(subd,listsubdirs)
